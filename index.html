<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>p5.js Sketch</title>
  <!-- Include p5.js library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    /* Ensure the canvas takes up the whole screen */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden; /* Prevent scrollbars */
    }

    #sketch-container {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100%;
    }
  </style>
</head>
<body>
  <!-- Container for p5.js sketch -->
  <div id="sketch-container"></div>

  <!-- Script to define p5.js sketch -->
  <script>
    // Global variables for p5.js sketch
    let imageStack = []; 
    let imageStackCopy = []; 
    let numImagesToShow; 
    let gridSize = 5; 
    let squareSize; 
    let gridStrokeWeight; 
    let borderStrokeWeight; 
    let totalGridSize; 
    let startX, startY; 
    let repeatImages = true; 
    let availableSquares = []; 
    let frameCounter = 0; 

    function preload() {
      // Load images asynchronously before setup (with repo path)
      let folderPalavras = '/ritarita/data/palavras/'; 
      let folderPedras = '/ritarita/data/pedras/'; 

      // Load images into imageStack
      loadImagesIntoStack(folderPalavras);
      loadImagesIntoStack(folderPedras);
    }

    function setup() {
      createCanvas(701, 701); // Adjust canvas size
      background(255); 
      
      squareSize = width / gridSize;
      gridStrokeWeight = width / 600; 
      borderStrokeWeight = width / 200; 
      
      // Calculate the total size occupied by the grid
      totalGridSize = gridSize * squareSize;
      
      // Calculate the starting positions to center the grid horizontally and vertically
      startX = (width - totalGridSize) / 2;
      startY = (height - totalGridSize) / 2;
      
      // Copy imageStack to imageStackCopy
      imageStackCopy = [...imageStack];
      
      frameRate(1); 
    }

    // Load all images from the specified folder into the stack
    function loadImagesIntoStack(folder) {
      fetch(folder)
        .then(response => response.text())
        .then(data => {
          let parser = new DOMParser();
          let doc = parser.parseFromString(data, 'text/html');
          let files = [];

          let links = doc.querySelectorAll('a');
          
          links.forEach(link => {
            let href = link.getAttribute('href');
            if (href.endsWith('.jpg') || href.endsWith('.jpeg') || href.endsWith('.png') || href.endsWith('.gif')) {
              let imagePath = href;
              files.push(imagePath);
            }
          });

          files.forEach(file => {
            loadImage(file, img => {
              imageStack.push(img);
            });
          });
        })
        .catch(error => {
          console.error('Error fetching folder content:', error);
        });
    }

    // Custom shuffle function for array
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        let index = Math.floor(Math.random() * (i + 1));
        let temp = array[index];
        array[index] = array[i];
        array[i] = temp;
      }
    }

    function draw() {
      background(255); 

      imageStackCopy = [...imageStack];
      
      // Draw the grid of squares
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          let x = startX + i * squareSize;
          let y = startY + j * squareSize;
          
          stroke(0);
          strokeWeight(gridStrokeWeight); 
          
          // Horizontal line
          for (let k = x; k <= x + squareSize; k += 10) {
            point(k, y);
          }
          
          // Vertical line
          for (let k = y; k <= y + squareSize; k += 10) {
            point(x, k);
          }
        }
      }
      
      // Clear and regenerate availableSquares list
      availableSquares = [];
      for (let i = 0; i < gridSize * gridSize; i++) {
        availableSquares.push(i); // Add all grid squares back to availableSquares
      }
      
      // Randomly choose how many images to show (between 1 and availableSquares.length)
      numImagesToShow = Math.min(Math.floor(Math.random() * (availableSquares.length)) + 1, gridSize * gridSize);
      
      // Place images in the grid squares
      for (let n = 0; n < numImagesToShow; n++) {
        if (availableSquares.length === 0 || imageStackCopy.length === 0) {
          break; 
        }

        let index = Math.floor(Math.random() * availableSquares.length);
        let squareIndex = availableSquares[index];
        availableSquares.splice(index, 1); 
        
        let i = squareIndex % gridSize;
        let j = Math.floor(squareIndex / gridSize);
        
        let x = startX + i * squareSize;
        let y = startY + j * squareSize;
        
        // Calculate a margin for placing images within each square
        let margin = 10; 

        shuffleArray(imageStackCopy);

        let img;
        if (repeatImages) {
          // If repeatImages is true, use the first image without removing
          img = imageStackCopy[0];
        } else {
          // Pop an image from the copy of the stack
          img = imageStackCopy.shift();
        }
        
        // Calculate image dimensions to fit within the square
        let imgWidth, imgHeight;
        let imgRatio = img.width / img.height;
        if (img.width > img.height) {
          imgWidth = squareSize - 2 * margin;
          imgHeight = imgWidth / imgRatio;
        } else {
          imgHeight = squareSize - 2 * margin;
          imgWidth = imgHeight * imgRatio;
        }
        
        // Calculate image position to center within the square
        let imgX = x + margin + (squareSize - 2 * margin - imgWidth) / 2;
        let imgY = y + margin + (squareSize - 2 * margin - imgHeight) / 2;
        
        image(img, imgX, imgY, imgWidth, imgHeight);
      }
      
      // Draw the white border around the entire grid
      strokeWeight(borderStrokeWeight); 
      stroke(255); 
      noFill(); 
      rect(startX, startY, totalGridSize, totalGridSize); 
      
    }
    
  </script>
</body>
</html>
